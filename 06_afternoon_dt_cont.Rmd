# Продолжаем с data.table

```{r setup5, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(data.table)
```


## Продолжаем с data.table

Вчера мы познакомились с библиотекой `data.table` и дата.тейблом как структурой данных с расширенным функционалом. Давайте освежим:

* Внутри квадратных скобок дата.тейбла к колонкам можно обращаться просто по именам, без выражений типа `df$column`.

* У дата.тейбла есть три элемента в квадратных скобках, они отделены запятыми: `dt[фильтр строк, выражение, параметр]`.
* Первый элемент позволяет выбрать, какие строки отфильтровать.
* Во втором элементе можно вывести колонку, создать новую колонку или применить к колонке какую-нибудь функцию.
* В третьем элементе можно сгруппировать наблюдения по значению в колонке.

Давайте загрузим наш датасет, чтобы нам было с чем работать:

```{r, include=FALSE}
dt <- fread("data/about_us_eng.csv")
```


```{r, eval=FALSE}
dt <- fread("about_us_eng.csv")
```

Вот так я могу посчитать средний размер обуви для всех респондентов в зависимости от того, сколько у них кошек, исключив тех, кто на этот вопрос не ответил:
```{r}
dt[cats != "this is too personal", mean(shoe_size), by = cats]
```

```{block, type = "rmdtask"}
Задание для разминки: Исключив тех, кто не выбрал ни Пепси, ни Колу, посчитайте, сколько в среднем братьев и сестёр у любителей каждого напитка.
```

### Счёт элементов с помощью .N

До этого момента во втором выражении мы всегда считали какую-нибудь статистику - например, среднее или максимум. Но что, если мы хотим просто узнать, *сколько* у нас людей, так или иначе ответивших на вопрос? Сколько человек, например, любят Пепси, а сколько Колу? Это делается с помощью специального символа: `.N`. Этот символ считает, сколько в дата.тейбле строк. Если использовать только его, то мы получим просто количество строк во всём нашем дата.тейбле:
```{r}
dt[, .N]
nrow(dt)
```
Но если использовать его вместе с `by = `, который группирует, то мы узнаем, сколько строк в каждой группе! То есть вот такая строка посчитает, сколько каких ответов на вопрос о любимой газировке:
```{r}
dt[, .N, by = soft_drink]
```
Кола лидирует - у неё 18 фанатов!

```{block, type = 'rmdtask'}
Задание: Посчитайте, сколько у нас на мастерской людей с разным уровнем игры на гитаре. Кого больше всего?
```

### Несколько группировок

Крайне часто мы хотим посчитать какую-нибудь статистику для каждого сочетания двух переменных. Представьте, что вы проводите эксперимент о влиянии кофеина и физической активности на решение задач. У вас есть две независимых переменных - во-первых, вы даёте испытуемым кофе, чай или воду, во-вторых, вы просите их пробежать километр, позаниматься йогой или просто посидеть перед тем, как они приступят к решению задач, и фиксируете, сколько задач решил каждый испытуемый. В итоге вам будет интересно, сколько в среднем задач решили испытуемые, которые пили кофе *и* бегали, испытуемые, которые пили кофе *и* занимались йогой, пили кофе *и* сидели, пили *чай* и бегали, ну и так далее. Посчитать это в дата.тейбле очень просто: нужно использовать две колонки в третьей части квадратных скобок, там, где `by = `. 

Чтобы сгруппировать по двум колонкам сразу, имена колонок нужно объединить с помощью специальной функции, вот так: `.(columnName1, columnName2)`.

Вот как посчитать средний размер обуви в зависимости от предпочтений в газировке и месяца рождения:
```{r}
dt[, mean(shoe_size), by = .(soft_drink, month)]
```
Количество группировок, в целом, не ограничено, чисто технически - группируйте хоть по ста колонкам. Но имейте в виду: если у вас в датасете, как у нас сейчас, 35 человек, то очень "детальные" группировки, скорее всего, приведут к тому, что во многих группах просто никого не будет. Например, сколько среди нас тех, кто обожает Пепси, выше 180 сантиметров, имеет двух котов и три глаза? Кстати, хороший вопрос.

```{block, type = "rmdtask"}
Задание: Сколько среди нас тех, кто обожает Пепси, выше 180 сантиметров, имеет двух котов и три глаза? Это задание можно выполнить как минимум двумя способами, используя разные части квадратных скобок. Попробуйте найти оба способа.
```


### Несколько выражений

Точно так же, как и колонок для группировки, выражений во втором элементе может быть несколько. Например, если нас интересует несколько статистик сразу, скажем, среднее и дисперсия. Для этого нужно объединить нужные нам функции той же самой функцией `.()`:

```{r}
dt[, .(mean(height), var(height)), by = eye_color]
```

Давайте соберём воедино:

```{r}
dt[, .(.N, mean(hair_length)), by = .(month, soft_drink)]

```

```{block, type="rmdtask"}
Что делает предыдущая строчка кода?
```

```{block, type="rmdtask"}
Задание: посчитайте значения квартилей роста для всех респондентов в зависимости от их предпочтений в напитках (Кола или Пепси плюс кофе или чай).
```

### Имена колонок

Вы могли заметить, что каждый раз, когда мы группируем дата.тейбл и считаем какие-нибудь аггрегированные значения типа среднего, то колонки с этими посчитанными значениями получают имена типа V1, V2 и т.п. Это не очень удобно - содержательное имя переменной это гарант того, что вы-читающий(-ая)-свой-старый-код-через-год или другие люди, которым вы свой код покажете, поймут, что в нём происходит. Давайте позаботимся о себе из будущего и научимся называть эти колонки содержательно.

## Указание имён при создании колонок

Имя колонки можно указать сразу при названии, вот так:
```{r}
dt[, .(mean_hair_length = mean(hair_length), var_hair_length = var(hair_length)), by = eye_color]
```
Обратите внимание, что имена колонок мы указываем внутри `.()`. То же самое будет верно и для одной колонки - если мы не указываем её имя, то оборачивать в точку её не обязательно (хотя с точкой всё тоже будет работать), а вот если указываем, то надо обязательно использовать `.()` даже для единственной колонки.

Вот так не сработает:
```{r, eval = FALSE}
dt[, mean_hair_length = mean(hair_length), by = eye_color]
```

Вот так работает:

```{r}
dt[, .(mean_hair_length = mean(hair_length)), by = eye_color]
```

К слову, вот эти две команды делают одно и то же:
```{r}
dt[, .(mean(hair_length)), by = eye_color]
```


```{r}
dt[, mean(hair_length), by = eye_color]
```

Таким образом мы можем задать имена колонкам при создании. Часто мы хотим переименовать колонки в уже существующем дата.фрейме - например, если вы собираете данные на Гугл.Формах, то именем колонки является текст вопроса, а это ужасно неудобно.

## Вечер в хату, вектор в `colnames()`

Функция `colnames()` не только возвращает имена колонок, но и может их менять. Это не специфично для дата.тейбла, это метод из base R, то есть, он сработает и с дата.фреймом. Чтобы переименовать колонку, нужно передать функции `colnames()` вектор с новыми именами колонок. Давайте переименуем колонку `cats` в `meow`.

```{r}
colnames(dt)
colnames(dt) <- c("height","eye_color","eye_number","beard","soft_drink","meow",
"gorgeous","siblings","hair_length","shoe_size","guitar","hot_drink","month","hogwarts","dream")
colnames(dt)
```
Можно не передавать вектор *всех* имён, а отфильтровать самую функцию `colnames()`, используя индекс колонки (`cats`/`meow` - шестая):
```{r}
colnames(dt)[6] <- "cats"
colnames(dt) #всё вернулось на круги своя
```

Минусы этого метода - тысячи их. А именно: во-первых, скажем так, странный синтаксис (мы присваиваем что-то функции, а меняется дата.тейбл? Почему мы индексируем функцию?). Во-вторых, надо или передавать вектор всех имён, или использовать индекс колонки - вдруг он поменяется...

К счастью, есть более удобная альтернатива.

## `setnames()` из библиотеки `data.table`

Функция `setnames()` имеет три аргумента: во-первых, собственно, имя дата.тейбла, в котором нужно переименовывать колонки, во-вторых, вектор старых имён, в-третьих, вектор новых имён. Для одной колонки:

```{r, eval = FALSE}
setnames(dt, old = "cats", new = "meow")
```

Для двух колонок:
```{r}
setnames(dt, old = c("cats", "hair_length"), new = c("meow", "hairlength"))
```

Эта команда переименует колонку `cats` в `meow`, а колонку `hair_length` в `hair_length`.

Давайте вернём всё обратно:

```{r}
setnames(dt, old = c("meow", "hairlength"), new = c("cats", "hair_length"))
```

Новые имена в `setnames()` можно не указывать вручную, а задавать как преобразование старых. Для этого нужно дать на вход параметру `new` не вектор имён, а функцию, которую вы хотите применить к старым именам. Например, функция `toupper()` превращает все строчные буквы в заглавные:
```{r}
toupper('abcd')
```
А вот что получится, если использовать её для нашего дата.тейбла:
```{r}
setnames(dt, old = 'cats', new = toupper)
colnames(dt)
```

Кстати, если не уточнять, какие колонки переименовываем, то `setnames()` применит это функцию ко всем. Вот такая команда сделает заглавными буквы во всех именах колонок:
```{r}
setnames(dt, toupper)
colnames(dt)
```
А вот такая вернёт всё обратно как было:
```{r}
setnames(dt, tolower)
colnames(dt)
```

### Новый дата.тейбл или колонка в существующем?

Напоследок давайте обсудим такую вещь: в этой главе мы всю дорогу использовали `=` во втором элементе дата.тейбловских квадратных скобок. Но ведь в первый день мы обсудили, что у дата.тейбла есть свой специальный оператор `:=`. Что будет, если использовать его?

Давайте посмотрим.

```{r}
dt[, mean_hair_length := mean(hair_length), by = eye_color]
```

Хммм, что-то ничего не происходит... Или происходит? Посмотрим, как теперь выглядит наш дата.тейбл:

```{r}
head(dt)
```
Опа! Смотрите сами: там появилась *новая колонка* со средней длиной волос в зависимости от цвета глаз. То есть, теперь в строке у каждого респондента есть не только его индивидуальные данные, но и данные о какой-то группе, к которой она или он относится.

Это логично, если вспомнить, что `:=` именно что создаёт новую колонку в существующем дата.тейбле - даже если вы сгруппировали дата.тейбл с помощью `by = `.

То есть, вот такая команда создаст новый дата.тейбл, в котором будет только группирующая переменная (здесь - цвет глаз) и то, что мы для неё посчитали (в данном случае среднюю длину волос):
```{r}
dt[, .(mean_hair_length = mean(hair_length)), by = eye_color]
```

Чтобы этот новый дата.тейбл можно было использовать потом, надо сохранить его в переменную:

```{r}
meanHairLengthByEyeColor <- dt[, .(mean_hair_length = mean(hair_length)), by = eye_color]
```


А вот такая команда добавит в существующий дата.тейбл новую колонку mean_hair_length_by_eye_color:
```{r}
dt[, mean_hair_length_by_eye_color := mean(hair_length), by = eye_color]
```

Никуда дополнительно её сохранять не надо - это делает `:=`.

```{block, type = "rmdtask"}
Задание. Почистите датасет (то есть, уберите все сомнительные ответы - глаза больше 2 и т.п.). Переведите длину волос из сантиметров в дюймы (для этого вам поможет знание, что 1 см = 0.3937 дюйма), а потом создайте новый дата.тейбл, в котором посчитайте среднюю длину волос в зависимости от количества братьев и сестёр, а также предпочтений в вопросах кофе и чая. А затем постройте график всего этого великолепия :)
```

```{block, type = "rmdtask"}
Задание. Скачайте датасет про разные виды мюсли (мюслей?..) на Kaggle, [вот тут](https://www.kaggle.com/crawford/80-cereals). Используя всё, что вы узнали про `data.table`, `ggplot2` и всяческие статистические тесты, расскажите и покажите один интересный факт о мюсли (мюслях?..).
```


