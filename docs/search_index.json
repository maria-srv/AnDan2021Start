[["введение-в-r.html", "3 Введение в R 3.1 Общее 3.2 Типы данных 3.3 Структуры данных 3.4 Функции и простые действия с данными 3.5 Задания для тренировки", " 3 Введение в R 3.1 Общее R — скриптовый язык. Важно помнить, что код в нем выполняется построчно. Многие функции в нем векторизованы, то есть выполняются ко всему списку объектов, что даются ему на вход. Это вы потом увидите на примерах. В R есть множество пакетов (помните, мы вводили install.packages() при подготовке к школе?), в которых реализованы наиболее эффективные алгоритмы работы с данными, именно поэтому он так удобен для анализа. 3.2 Типы данных С некоторыми типами данных мы уже познакомились выше. Все они, кроме фактора, более-менее стандартны для всех языков программирования. 3.2.1 Целое число — integer Например, в R можно что-нибудь посчитать как на калькуляторе. 6/3 ## [1] 2 Чтобы определить тип данных есть команда typeof(): b &lt;- 6 ** 2 typeof(b) ## [1] &quot;double&quot; Ой, у нас вышло, что эта переменная не целочисленная, а double — число с плавающей точкой. Хранение в памяти такого числа требует больше ресурсов. Можно перевести переменную в integer: b &lt;- 6 ** 2 b &lt;- as.integer(b) typeof(b) ## [1] &quot;integer&quot; 3.2.2 Число с плавающей точкой — double Этот формат — для всех целочисленных и дробных значений. 2.5 + 3.3 ## [1] 5.8 Результат деления всегда будет числом с плавающей точкой, даже если результат целочисленный: c &lt;- b / 2 paste(c) ## [1] &quot;18&quot; typeof(c) ## [1] &quot;double&quot; Основные операторы для арифметических действий: + — сложить - — вычесть * — умножить ** или ^ — возвести в степень %% — получить остаток от деления %/% — получить целочисленную часть от деления sqrt() — извлечь квадратный корень round() — округлить 3.2.3 Комплексные числа — complex Кто знает, тот поймет. 3.2.4 Символьный тип данных (строки) — character s1 &lt;- &quot;Я строка&quot; s2 &lt;- &#39;И я строка&#39; s1 ## [1] &quot;Я строка&quot; s2 ## [1] &quot;И я строка&quot; В кавычках '' или \"\" заключены символьные данные. Следите за тем, чтобы не пропустить открывающие/закрывающие кавычки. s3 &lt;- &quot;Экранирование \\&quot;лишних\\&quot; кавычек&quot; s3 ## [1] &quot;Экранирование \\&quot;лишних\\&quot; кавычек&quot; R (как и другие языки) может читать текст вместе со специальными управляющими символами (такими, например, являются кавычки ' и \" или бэкслэш \\), а может читать просто как текст. Специальные символы можно экранировать, добавив перед ними бэкслэш. Выполнять мат. операции с символьными значениями нельзя. &#39;a&#39; * 3 ## Error in &quot;a&quot; * 3: non-numeric argument to binary operator Для соединения символьных и числовых данных часто необходимо превратить числовое значение в символьное. Соединить две строки помогает функция paste(). Ей через запятую можно передать строки, которые она соединит в одну строку. Стандартный разделитель - пробел \" \". paste(&#39;я&#39;, &#39;люблю&#39;, &#39;людей&#39;) ## [1] &quot;я люблю людей&quot; Сепаратор можно задать и самим: paste(&#39;я&#39;, &#39;люблю&#39;, &#39;людей&#39;, sep=&#39;;&#39;) ## [1] &quot;я;люблю;людей&quot; Если хочешь, чтобы сепаратором стала пустая строка \"\", используй функцию paste0() paste0(&#39;я&#39;, &#39;люблю&#39;, &#39;людей&#39;) ## [1] &quot;ялюблюлюдей&quot; У тебя есть переменная: age - с твоим возрастом. Попробуй вывести на экран с помощью функции paste() фразу “Мой возраст:” и свой возраст. Не забудь превратить число возраста в строку с помощью функции as.character(). 3.2.5 Фактор — factor Ну а что же такое факторы # ://////////++++++++++++++++++++++++++++++++++//////:::::::::::::/::::: # //////////+++++++++++++++++++++++++++++++ossoo++/////++syyo+//:////::: # ///////////++++++++++++++++++++++++++++//:/+shhhhhhddddddddhyo//////:: # ////////////++++/++++++++////+++ooo+++syyyysssyyyhdmmmdddddhhy+//////: # ////////////////+osyhddho:::osshddddhhysyhhyyyyyhysosydmmmmddhy//////: # //////////////+syhdmmmdh+/oyyhdddhhhhhdddhso+++syhhyo+/+shdmdddo/////: # ///////+oyhhhhdmmmmmmhs//shhdhssssysooooo++/+ss//+oooso/::/+yddh/////: # ///osyhmmmmmmmmmmmmho::/osyhyyssoossyyssssyhhy/:/shhhyysso+/:/shs///:: # /+hmddmmmmmmmmmmmds:-::++oys+//sys+//oyooshyyho+oydmdddddddyo+:+hho/:: # +smdmmmmmmmmmmmmh+---::++//+oydmmddsoohsoyhyyhyyyhdmdhhydddddyo/sso/:: # +ohmmmmmmmmmmmds:---::///shdmmdmmmddhhhssyyhhhhyyyyhdy+hdhddddy+/:::-- # ++odmmmmmmmmmd+------::ohddddddhhdmddhhhdddddddddhsssssydhddddh+/:---- # +++odmmmmmmmd+------:/ohhddddddhyyddhhdmdhdhhhdhdddhyssyhdddddho+:---. # ++++ymmmmmmmh:-.--::+shhddmydhddhhysyhmdhhdmhhhddddddhhyyyddddyoo:.... # ++++odmmmmmdy-----:/shhhhddddddhhssshdmddhhdhdyhhhdddddddhhddhs++/.... # ++++++ydddddy----::+yddhhhhhhyyhsoshmddddhhhdhhhddddddddddddhhyo+/:... # /++++++oshhhs-----:/shhyyhdddddyosdmddddhhhhhddhyyhhhddddddddhyys/:-.. # ++++++++++/o+--.-----/+sssyyyhyoydmmddddhhhhhhdmdddddddddddddddhyo::-. # +++++++++/--:-..-+/..-:+osssyyssdmmdddddhhyhdddhyyhdddddddddddddhs//-- # /++++++++/---...-/:.-:+o++/+ssshmdddddddhhhddhhdddddddmdddddddddho//:- # +++++++++/:::-..-:---/ooo+/+ysydmddddddddddmddddddddddmmmddddddds+/::: # ++++++++:-...-....--:+yysoshhhdmmmmmddddddmdddddddddddmmmmmmmdddoo/::: # +++++++/-..`..-...-:/+syyhdddmmddddddddddmmdddmmmmmdddmmmmmmmmdyo/:::: # ++++++/:-.....--.---:/oyhddddddhhdddddmmmmmddmmmmmmdddmmmmmdddyo//:::/ # /+++++/--.--...------:/ohddmmmdddddmmmmmmdmmmmmmmmmmddmmmmmddys+///:/: # //////:....--...-:::::/+shhdddmmmmmmmmdmmmmmmmmmmmdmmmmmmmdhyo//:/::/: # /////:.......--..-:::::/+shddmddmmmmdmmmmmmmmmmmmmmmmmmddhhso////:///: # :///:.``.....---..-::::/+osyhdmmmmmmmmmmmmmmmmddmmmmmdyyyyo+////::/::: # ::::-.```...--::-.------::/+syhdddddddmdddhyyyyhddmmhso+++/:://::::::: # ::::.``````..-:::--..----::/+oossssyhddyo+:://oyhhys+:::/::::/::::::-- # :::-.```````....-:--...------:::::/oso/-----::/++//:--::::://::::---.. # :::-`````````....----....--....-------......--::::::/::::://::::--.... # -::-.````.......--:---......-......------:::/+++++//////:::::---...... Фактор был придуман для облегчения работы с качественными переменными, он может быть представлен как строка, и как число. Например, возьмем последовательность букв алфавита f &lt;- factor(LETTERS) На них можно посмотреть как на строковые данные: as.character(f) ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; И как на числовые: as.numeric(f) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 Если нам нужно каждому варианту ответа присвоить код (номер), то это удобно сделать с помощью фактора: dogs &lt;- c(&quot;мопс&quot;, &quot;пудель&quot;, &quot;овчарка&quot;, &quot;йорк&quot;, &quot;мопс&quot;, &quot;мопс&quot;) f_dogs &lt;- factor(dogs) f_dogs ## [1] мопс пудель овчарка йорк мопс мопс ## Levels: йорк мопс овчарка пудель as.numeric(f_dogs) ## [1] 2 4 3 1 2 2 У факторов есть уровни и они сортируются по алфавиту levels(f_dogs) ## [1] &quot;йорк&quot; &quot;мопс&quot; &quot;овчарка&quot; &quot;пудель&quot; str(f_dogs) ## Factor w/ 4 levels &quot;йорк&quot;,&quot;мопс&quot;,..: 2 4 3 1 2 2 Допустим, мы хотим отсортировать уровни по-своему f_dogs2 &lt;- factor(dogs, levels=c(&quot;овчарка&quot;, &quot;мопс&quot;, &quot;йорк&quot;, &quot;пудель&quot;)) f_dogs2 ## [1] мопс пудель овчарка йорк мопс мопс ## Levels: овчарка мопс йорк пудель str(f_dogs2) ## Factor w/ 4 levels &quot;овчарка&quot;,&quot;мопс&quot;,..: 2 4 1 3 2 2 str(f_dogs) ## Factor w/ 4 levels &quot;йорк&quot;,&quot;мопс&quot;,..: 2 4 3 1 2 2 Изменение уровней фактора levels(f_dogs) &lt;- c(&quot;йорк&quot;, &quot;шарпей&quot;, &quot;овчарка&quot;, &quot;пудель&quot;) #меняем мопсов на шарпеев f_dogs ## [1] шарпей пудель овчарка йорк шарпей шарпей ## Levels: йорк шарпей овчарка пудель 3.2.6 Упорядоченный фактор — ordered factor Допустим мы хотим знать, какая собака больше (чуть более реальный пример: размер одежды S-M-L и т.д. как фактор) f_dogs[1] &lt; f_dogs[2] ## Warning in Ops.factor(f_dogs[1], f_dogs[2]): &#39;&lt;&#39; not meaningful for factors ## [1] NA o_f_dogs &lt;- factor(f_dogs, ordered = TRUE, levels = c(&quot;йорк&quot;, &quot;пудель&quot;, &quot;шарпей&quot;, &quot;овчарка&quot;)) o_f_dogs ## [1] шарпей пудель овчарка йорк шарпей шарпей ## Levels: йорк &lt; пудель &lt; шарпей &lt; овчарка o_f_dogs[1] &lt; o_f_dogs[2] ## [1] FALSE При неупорядоченных факторах мы получили NA, при упорядочивании мы получили возможность сравнивать разные уровни. В нашей таблице у нас есть возможность представить строковые значения как факторы с помощью флажка stringsAsFactors = TRUE (по умолчанию он равен FALSE) data &lt;- read.table(file = &quot;about_us_eng.csv&quot;, sep=&quot;,&quot;, header=TRUE, stringsAsFactors = TRUE) data$beard ## [1] no no no no no no yes no no no no no no no no no no no no ## [20] yes no no no no no no no no no no no no no yes no ## Levels: no yes 3.2.7 Логические — boolean Логические данные имеют всего два вида: TRUE либо FALSE. Они часто возникают, когда мы хотим проверить какое-то условие: a == b ## Error in eval(expr, envir, enclos): object &#39;a&#39; not found Операторы сравнения будут те же, что ф вормальной логике: == — равно != — не равно &gt; , &lt; — больше, меньше &gt;= — больше или равно &lt;= — меньше или равно Для объединения условий также есть специальные символы: &amp;&amp; или &amp; — и, ответ правда если оба условия правда ||' или|--- или, ответ правда если хотя бы одно условие правда!` — не, отрицание выражения, смена правды на ложь и наоборот У тебя есть две переменных: d &lt;- 24, e &lt;- 41. Проверьте условие: остаток от деление нацело этих двух переменных больше 0. Кстати, остаток от деления на 2 помогает проверить число на четное или нечетное. С логическими данными можно выполнять мат. операции, тогда TRUE — это 1, FALSE — это 0: c + TRUE ## [1] 19 NB! Допустимо использование вместо TRUE и FALSE сокращенного их вида: T и F. Но помните, что TRUE и FALSE — это служебные слова, эти имена невозможно присвоить, например, переменным. T и F такими не являются. Будьте осторожны с чужим кодом, и сами лучше не давайте такие имена объектам в коде. 3.2.8 Даты В R есть отдельные функции для облегчения работы с датами. Например, можно посчитать сколько дней прошло между двумя заданными датами. Как же их задавать? date1 &lt;- as.Date(&quot;2019-07-24&quot;) date1 ## [1] &quot;2019-07-24&quot; Можно писать другие форматы, но к ним нужны пояснения date2 &lt;- as.Date(&quot;07/24/2019&quot;, format = &quot;%m/%d/%Y&quot;) date2 ## [1] &quot;2019-07-24&quot; date1 ## [1] &quot;2019-07-24&quot; date3 &lt;- as.Date(&quot;24.07.2019&quot;, format = &quot;%d.%m.%Y&quot;) date3 ## [1] &quot;2019-07-24&quot; date1 ## [1] &quot;2019-07-24&quot; date4 &lt;- as.Date(&quot;07/24/19&quot;, format = &quot;%m/%d/%y&quot;) date4 ## [1] &quot;2019-07-24&quot; date1 ## [1] &quot;2019-07-24&quot; Вот так можно посмотреть список всех этих сокращений от даты и от времени (например, большая M — это минуты) `?`(strptime) Мы можем узнать системное время (определяется по твоему компу) и сравнить его с переменной Sys.Date() ## [1] &quot;2021-08-03&quot; date1&lt;Sys.Date() ## [1] TRUE 3.2.9 Пропущенные значения — missing values Часто в данных нам будут попадаться пропущенные значения. В R для них отдельное обозначение: NA. Многие встроенные функции с ними не работают, и тогда нам нужно выбирать: исключить пропущенное значение или заполнить его на основании какого-то предположения. При работе с грязными данными (то есть теми, которые не приведены к общему формату и с которыми неудобно работать) могут возникать ситуации, что вместо NA у вас будут или пустые строки \"\"или пробелы \" \". Их можно заменять на другие значения, в том числе на NA. 3.3 Структуры данных 3.3.1 Вектор Это самая базовая, простая структура. Вектор — это последовательность элементов одного и того же типа. Вектор можно создать командой конкатенации с(): a&lt;-c(1,2,3,3,2,1) a ## [1] 1 2 3 3 2 1 С числовыми векторами можно осуществлять самые разные преобразования. Благодаря векторизованности языка R, нам нет необходимости писать цикл, который будет применять операции к каждому елементу вектора. R это сделает сам. арифметические операции a*2 ## [1] 2 4 6 6 4 2 a*c(1,2,3,4) ## Warning in a * c(1, 2, 3, 4): longer object length is not a multiple of shorter ## object length ## [1] 1 4 9 12 2 2 a-5 ## [1] -4 -3 -2 -2 -3 -4 a^2 ## [1] 1 4 9 9 4 1 a/2 ## [1] 0.5 1.0 1.5 1.5 1.0 0.5 Как видите, чтобы перемножить вектора, они должны быть одинаковой длины: a*c(1,2,3,4,5,6) ## [1] 1 4 9 12 10 6 операции сравнения (важно! = — оператор присваивания! для сравнения используйте ==) a&lt;=1 ## [1] TRUE FALSE FALSE FALSE FALSE TRUE a!=1 ## [1] FALSE TRUE TRUE TRUE TRUE FALSE a==1 ## [1] TRUE FALSE FALSE FALSE FALSE TRUE В результате мы получаем вектор логических значений. Запомним, это пригодится нам далее. Вспомним, что в логических переменных TRUE — это 1, FALSE — это 0 tf = c(TRUE,TRUE,FALSE,TRUE) tf == 1 ## [1] TRUE TRUE FALSE TRUE tf == 0 ## [1] FALSE FALSE TRUE FALSE sum(tf) ## [1] 3 sum(tf == 0) ## [1] 1 Наш датасет, хранящийся в data, имеет 15 столбиков. Каждый столбик — это вектор. Мы можем извлекать их оттуда через знак $: data$height ## [1] 165 180 161 164 180 170 170 173 163 168 165 164 166 NA 173 173 183 170 185 ## [20] 169 185 172 158 185 168 175 162 182 164 167 175 167 168 179 172 У нас в данных есть NA —пропущенное значение: data$height[1:10]==164 ## [1] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE data$height[1:10] — это выбор первых десяти значений из вектора, которые мы протом проверяем на равенство 164 Мы можем посчитать частоту каждого значения с помощью функции table() table(data$height) ## ## 158 161 162 163 164 165 166 167 168 169 170 172 173 175 179 180 182 183 185 ## 1 1 1 1 3 2 1 2 3 1 3 2 3 2 1 2 1 1 3 Вспомним, что мы можем совершать арифметические действия с логическими переменными и посчитаем, сколько человек выше 175см: sum(c(TRUE,TRUE,FALSE,TRUE)) ## [1] 3 sum(data$height&gt;175) ## [1] NA Опа, посчитать не получилось. Это потому что каждый элемент вектора нужно сравнить с 175, а для пропущенного значения это невозможно. давайте просто не будем его учитывать: sum(data$height&gt;175, na.rm=TRUE) ## [1] 8 Посчитаем среднее количество глаз на каждого из нас: mean(data$eye_number) ## [1] 5.057143 Все понятно, мы — ангелы Гистограмма распределения размеров обуви и самый большой размер: shoes&lt;-data$shoe_size hist(shoes) max(shoes) ## [1] 45 Вектор может быть именованным и к каждому элементу тогда можно обратиться по имени: b&lt;-c(&quot;e&quot;=1,&quot;f&quot;=2,&quot;g&quot;=3) b ## e f g ## 1 2 3 b[&#39;f&#39;] ## f ## 2 names(b) ## [1] &quot;e&quot; &quot;f&quot; &quot;g&quot; А если имени нет? Тогда можно по номеру в последовательности: b[2] ## f ## 2 Или сразу по вектору номеров! NB! В R нумерация элементов начинается с 1, но не в каждом языке программирования так. b[c(1,3)] ## e g ## 1 3 Или по логическому вектору отфильтровать другой вектор: b[c(TRUE,FALSE,TRUE)] ## e g ## 1 3 Мы можем выбрать не одну, а несколько колонок из таблицы с помощью вектора: data[c(&quot;eye_color&quot;,&quot;gorgeous&quot;)] 3.3.2 Матрицы Матрица - такая структура данных, где есть столбики и строки. Вектор может быть превращён в матрицу. Для этого надо сказать, сколько в нём строчек или столбиков. Пока что они нам не пригодятся. 3.3.3 Списки Список (list) - структура, которая может включать в себя набор из данных разного формата, например, вектор и строку, число и матрицу и пр. u0 &lt;- list(&#39;A&#39;, 1) u0 ## [[1]] ## [1] &quot;A&quot; ## ## [[2]] ## [1] 1 Мы можем посмотреть структуру объекта: u &lt;- list(&quot;A&quot;, 1, list (&quot;A&quot;, T)) str(u) ## List of 3 ## $ : chr &quot;A&quot; ## $ : num 1 ## $ :List of 2 ## ..$ : chr &quot;A&quot; ## ..$ : logi TRUE Представим, что список — это мешочек. Функция unlist() вытаскивает предметы из мешочка и просто выставляет их на стол uu &lt;- c(list(&quot;a&quot;,5),list(list(5))) str(uu) ## List of 3 ## $ : chr &quot;a&quot; ## $ : num 5 ## $ :List of 1 ## ..$ : num 5 unlist(u) ## [1] &quot;A&quot; &quot;1&quot; &quot;A&quot; &quot;TRUE&quot; Можно превратить список в другие структуры данных, например, таблицу или матрицу. u &lt;- list(&quot;a&quot;=c(1,2),&quot;b&quot;=c(3,4)) str(u) ## List of 2 ## $ a: num [1:2] 1 2 ## $ b: num [1:2] 3 4 u2 &lt;- as.data.frame(u) u3 &lt;- as.matrix(u2) u4 &lt;- as.matrix(u) Найдите эти переменные в глобальном окружении. Выглядят они похоже, но описания у них в глобальном окружении разные, как и принципы работы с ними. Элементам списка также можно давать имена, а не обращаться к ним по номерам: u &lt;- list(&#39;a&#39;, matrix(c(1, 2))) names(u) &lt;- c(&#39;meow&#39;, &#39;meow_num&#39;) u ## $meow ## [1] &quot;a&quot; ## ## $meow_num ## [,1] ## [1,] 1 ## [2,] 2 Выведем второй элемент списка и посмотрим, какой тип данных он имеет: u[2] ## $meow_num ## [,1] ## [1,] 1 ## [2,] 2 class(u[2]) ## [1] &quot;list&quot; Второй элемент этого списка был превращен из матрицы с одной колонкой в вертикальный список с именем meow_num, состоящий из одного элемента — матрицы. Чтобы нам добраться до самого второго элемента именнованного списка — матрицы — нужно использовать двойные скобки [[x]]. Это особенность синтаксиса. u[[2]] ## [,1] ## [1,] 1 ## [2,] 2 class(u[[2]]) ## [1] &quot;matrix&quot; &quot;array&quot; Либо обратиться не по индексу, а по имени: u$meow ## [1] &quot;a&quot; 3.3.4 Дата фреймы Это наши любимые таблицы. В каждом столбце находятся элементы одного типа. В переменной data находится наш датафрейм. Как и с векторами, есть три базовых способа фильтрации датафреймов: с помощью вектора с адресами (номерами строк) data10_1&lt;-data[1:10,] с помощью вектора с именами data10_1&lt;-data[c(1:5,7:10),c(&quot;soft_drink&quot;,&quot;hot_drink&quot;)] С помощью логического вектора (rep() - функция, генерирующая повторяющиеся значения) data10_1&lt;-data[c(rep(TRUE,10),rep(FALSE,25)),] Подробнее о логической фильтрации будет в следующем уроке. 3.3.5 Другие Есть структуры данных более высокого уровня: функции, циклы, классы (например, класс numeric), объекты. С частью из них мы познакомимся далее. 3.4 Функции и простые действия с данными Для начала мы можем узнать тип данных, из которых состоит вектор. ch &lt;- c(&#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;orange&#39;) ch ## [1] &quot;apple&quot; &quot;pear&quot; &quot;banana&quot; &quot;orange&quot; typeof(ch) ## [1] &quot;character&quot; Сколько уникальных элементов содержится в векторе? ch2 &lt;- c(&#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;apple&#39;) unique(ch2) ## [1] &quot;apple&quot; &quot;pear&quot; &quot;banana&quot; &quot;orange&quot; sort(ch2) #сортировка объектов ## [1] &quot;apple&quot; &quot;apple&quot; &quot;apple&quot; &quot;banana&quot; &quot;orange&quot; &quot;pear&quot; Фильтруем все, что по алфавиту идет раньше ‘ba’. При этом считается, что ‘ba..’ идет позже просто ‘ba’ ch[ch&gt;&quot;ba&quot;] ## [1] &quot;pear&quot; &quot;banana&quot; &quot;orange&quot; Сколько символов в элементах вектора? length(ch) ## [1] 4 nchar(ch) ## [1] 5 4 6 6 Поиск элементов grep(&#39;b&#39;, ch, value=TRUE) #дает само значение ## [1] &quot;banana&quot; grep(&#39;b&#39;, ch, value=FALSE) #дает порядковый номер элемента ## [1] 3 ch[grep(&#39;b&#39;, ch, value=FALSE)] #определяет значение по порядковому номеру элемента ## [1] &quot;banana&quot; Bывод элемента по номеру ch2[1] ## [1] &quot;apple&quot; Исключение элемента по номеру ch2[-4] ## [1] &quot;apple&quot; &quot;pear&quot; &quot;banana&quot; &quot;apple&quot; &quot;apple&quot; ch[-1] ## [1] &quot;pear&quot; &quot;banana&quot; &quot;orange&quot; ch2[-c(1, 2)] ## [1] &quot;banana&quot; &quot;orange&quot; &quot;apple&quot; &quot;apple&quot; Разбиение по разделителю (пробел) text &lt;- &#39;Ну-ка фрукты встаньте в ряд&#39; strsplit(text, &#39; &#39;) ## [[1]] ## [1] &quot;Ну-ка&quot; &quot;фрукты&quot; &quot;встаньте&quot; &quot;в&quot; &quot;ряд&quot; a &lt;- strsplit(text, &#39; &#39;) typeof(a) ## [1] &quot;list&quot; typeof(a[1]) ## [1] &quot;list&quot; Строка с пропусками вида character и digit sprintf(&quot;%s отправляется в %d часов&quot;, &quot;Электричка&quot;, 12) ## [1] &quot;Электричка отправляется в 12 часов&quot; sprintf(&quot;%s отправляется в %d часов&quot;, rep(&quot;Электричка&quot;, 2), c(12, 13)) ## [1] &quot;Электричка отправляется в 12 часов&quot; &quot;Электричка отправляется в 13 часов&quot; Вытащить кусок строки substr(&quot;Я маленькая лошадка&quot;, start=3, stop=12) ## [1] &quot;маленькая &quot; Заменить кусок внутри строки sub(&quot;маленькая&quot;, &quot;большая&quot;, &quot;Я маленькая лошадка&quot;) ## [1] &quot;Я большая лошадка&quot; sub(&quot;маленькая&quot;, &quot;большая&quot;, &quot;Я маленькая маленькая лошадка&quot;) #заменяет только первое появление подстроки ## [1] &quot;Я большая маленькая лошадка&quot; gsub(&quot;маленькая&quot;, &quot;большая&quot;, &quot;Я маленькая маленькая лошадка&quot;) ## [1] &quot;Я большая большая лошадка&quot; Отбор элементов по номеру позиции (индекс) и по его значению d &lt;- c(1,2,6,4) d&gt;2 ## [1] FALSE FALSE TRUE TRUE d[d&gt;2] #сами элементы ## [1] 6 4 which(d&gt;2) #номера их позиций ## [1] 3 4 Можно проверить, принадлежат ли элементы вектора определенному типу данных int_num&lt;-c(1,2,3,4000) is.integer(int_num) ## [1] FALSE typeof(int_num) ## [1] &quot;double&quot; К целочисленному выражению элементы вектора можно привести несколькими способами: int_num&lt;-as.integer(c(1,2,3,4000)) int_num&lt;-c(1L,2L,3L,4000L) #сохраняет как целые as.integer(214748364.7) ## [1] 214748364 as.integer(2147483648) #слишком большое число, не может хранить ## Warning: NAs introduced by coercion to integer range ## [1] NA as.integer(-2147483647) ## [1] -2147483647 as.integer(-2147483648) ## Warning: NAs introduced by coercion to integer range ## [1] NA Для больших чисел мы вынуждены использовать формат с плавающей точкой, он может хранить больше информации as.double(&quot;10000998843483274893274892374238947273&quot;) ## [1] 1.0001e+37 Включение scientific notation options(scipen=999) 2^64 ## [1] 18446744073709551616 90071992547409923 ## [1] 90071992547409920 options(scipen=0) 2^64 ## [1] 1.844674e+19 90071992547409923 ## [1] 9.007199e+16 Numeric - класс, общее название для числовых данных, включает в себя и double, и integer. Подробнее о форматах можно посмотреть в справке ?double и ?integer. numeric_num&lt;-c(1,2,2.5) is.integer(numeric_num) ## [1] FALSE is.integer(int_num) ## [1] TRUE is.numeric(int_num) ## [1] TRUE is.numeric(numeric_num) ## [1] TRUE str(numeric_num) ## num [1:3] 1 2 2.5 is.double(numeric_num) ## [1] TRUE typeof(numeric_num) ## [1] &quot;double&quot; Объединение векторов с разнымм типами значений n &lt;- c(1,2,3) s &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) c(n,s) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; Как видите, при объединении числовой формат был переделан в строковый. Как мы узнали ранее, разные форматы можно хранить только в списках и таблицах. 3.5 Задания для тренировки Соедини значение 1 и TRUE в вектор. Что получилось? У тебя есть вектор 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. Создай из него матрицу с заполнением по строкам. Выбери первый столбец. Помни, что при фильтрации в формате vec[x, y], x— это строка, y — это столбец. Список со вложенными списками subjects &lt;- list(list(‘Masha’, 18, list(39, 40)), list(‘Nastya’, 22, 41), list(‘Mitya’, 25, 46)). Выведи второй элемент третьего элемента первого списка. Что это за число? Поэкспериментируй. Не забудь про двойные кавычки [[]]. Определи среднее, сумму, максимальное и минимальное значение в векторе data$hair_length. Нарисуй гистограмму. Выведи вектор, получившийся в результате проверки каждого элемента из data$hair_length на четность/нечетность (используй остаток от целочисленного деления) Из нашей таблицы data выбери элемент, находящийся на 18 строке в 6 столбце и выведи на экран с помощью функции paste() "]]
