# Фильтрация строк и столбцов в base R. Введение в data.table

```{r setup2, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(data.table)
```

## Фильтрация строк и столбцов в base R

Из прошлой главы вы узнали, как вообще выглядит RStudio, какие звери (в смысле, типы и структуры данных) в нём обитают, и даже научились фильтровать элементы векторов и дата.фреймов по индексам и по именам. Но есть ещё один очень важный способ фильтрации - это фильтрация по условию.

### Фильтрация вектора по условию

Фильтрация по условию нужна, когда вы хотите выбрать только ту часть данных, которая удовлетворяет какое-нибудь (вы не поверите) условие. Например: ваш коллега провёл эксперимент и записал возраста всех ваших испытуемых в вектор. Теперь вы хотите посчитать средний возраст испытуемых, чтобы описать его в методах будущей великой статьи, но вот незадача для исследовательского вопроса вам подходят только те, кому больше 18 и меньше 45, а ваш коллега записывал возраста всех, кто пришёл. Так что надо найти в этом векторе тех, кто слишком млад или слишком стар, и исключить их, а уж потом считать хоть среднее, хоть медиану, хоть дисперсию.

Давайте для начала создадим вектор возрастов (я придумала их из головы).

```{r}
ages <- c(25, 69, 23, 27, 32, 45, 21, 16, 19, 17, 20, 55, 27, 18, 16, 39, 14)
```

Чтобы найти, где в нашем векторе люди, которым больше 45, мы можем воспользоваться логическим оператором "больше":
```{r}
ages > 45
```
Первый TRUE находится на 2 месте в получившемся логическом векторе, так что мы знаем, что седьмой человек в векторе возрастов старше 45. И правда, ему (или ей) 69 лет:
```{r}
ages[2]
```

Но мы же не будем каждый раз вручную искать, где в нашем логическом векторе TRUE? Конечно, не будем! Потому что этот логический вектор можно использовать для фильтрации! Фильтрация с помощью логического вектора работает просто: если на месте элемента в логическом векторе стоит TRUE, мы его включаем, а если FALSE, то не включаем.

Если мы используем логический вектор, который получается в результате команды `ages > 45`, для фильтрации нашего вектора ages, то получим следующий вектор:
```{r}
ages[ages > 45]
```

Упс, кажется, это не то, чего мы хотели! Мы включили все элементы, которые удовлетворяют нашему условию - то есть те, которые *больше* 45. А нам-то надо, наоборот, оставить тех, кому *меньше* 45! Давайте это сделаем:
  
```{r}
ages[ages < 45]
```

Ура! Но подростки всё ещё остались. Что делать с ними? Мы можем соединить сочетание двух логических условий с помощью логического оператора "и" - `&`. Для начала давайте посмотрим на сам логический вектор, который у нас получается:
```{r}
ages < 45 & ages > 18
```
Логический оператор `&` возвращает TRUE, только если удовлетворены оба условия - так что теперь в нашем векторе TRUE получили только те испытуемые, возраст которых нам подходит, так что именно их мы и отберём, если используем этот вектор для фильтрации. Вот так счастье! Вот так радость! Давайте же, наконец-то, узнаем средний возраст наших корректных испытуемых:
  
```{r}
correctAges <- ages[ages < 45 & ages > 18]
mean(correctAges)
```

Ура!
  
![](images/celebration.gif)



### Фильтрация дата.фрейма по условию

Такую логику фильтрации можно применять не только к векторам, но и к любым табличным данным - например, к матрицам или дата.фреймам.

Давайте загрузим наш дата.фрейм в переменную `df` (не забудьте указать правильную рабочую директорию - папку, в которой лежит файл у вас на компьютере) и посмотрим, как он выглядит:

```{r, include=FALSE}
df <- read.csv("data/about_us_eng.csv")
```


```{r, eval=FALSE}
df <- read.csv("about_us_eng.csv")
```


```{r}
str(df)
```
Ага, прекрасно. Например, у нас в датасете есть колонка `eye_number` - там был вопрос "Сколько у вас глаз?". Скорее всего, люди, которые ответили, что у них больше двух глаз, или шутники, или шестикрылые серафимы - так или иначе, давайте исключим их из нашего очень серьёзного опроса. Как мы можем это сделать?
  
  Логика здесь совершенно та же, что и в прошлом примере - мы воспользуемся логическим вектором. Для этого нам нужно вспомнить ещё два факта: во-первых, фильтровать дата.фрейм мы можем и по строкам, и по столбцам. Например, вот такая команда выберет только строки с индексами от 1 до 5 (то есть первые пять) и столбцы с индексами от 1 до 10 (то есть первые десять):
```{r}
df[1:5,1:10]
```

Во-вторых, мы можем "вытащить" колонку дата.фрейма и обращаться с ней, как с вектором, с помощью знака доллара, `$`. Вот такая команда сохранит в переменную `eyeNumberVec` колонку `eye_number` наше дата.фрейма `df`:
```{r}
eyeNumberVec <- df$eye_number
eyeNumberVec
```

Эту вытащенную колонку мы можем проверить на соответствие нашему условию (не больше двух глаз):
```{r}
eyeNumber2Below <- eyeNumberVec <= 2
eyeNumber2Below
```

Каждая строка нашего дата.фрейма этот ответ одного респондента на все вопросы. Так что, если мы используем этот вектор, чтобы оставить в нашем дата.фрейме только строки, в которых у респондента не больше двух глаз, то и многоглазых респондентов в нашем дата.фрейме не останется. Это может немного запутать в самом начале: условие у нас для колонки (не больше 2 в колонке `eye_number`), а убираем мы строки. Раз убираем строки, то и используем наше условие в той части квадратных скобок, где строки. То есть - до запятой.

```{r}
dfOnly2Eyes <- df[eyeNumber2Below,]
```

Всё то же самое можно сделать, не создавая промежуточные вектора `eyeNumberVec` и `eyeNumberVecBelow2`:
  
```{r}
dfOnly2Eyes <- df[df$eye_number <= 2,]
```

Часто мы хотим фильтровать данные по нескольким условиям сразу, зачастую достаточно сложным - например, давайте оставим только гриффиндорцев, у которых или очень короткие волосы (короче 10 см) или очень маленький размер ноги (меньше 38).

Конечно, это всегда можно сделать в два этапа - сначала выбрать гриффиндорцев, а потом из них выбрать коротковолосых или мелконогих:
```{r}
dfOnlyGr <- df[df$hogwarts == "Gryffindor",]
dfOnlySmallGr <- dfOnlyGr[dfOnlyGr$hair_length < 10 | dfOnlyGr$shoe_size < 38]
```

Но у нас в среде останется этот вспомогательный дата.фрейм `dfOnlyGr`... Давайте лучше соединим оба условия воедино - а чтобы указать, как они между собой соотносятся, воспользуемся круглыми скобкам:
```{r}
dfOnlySmallGr <- df[df$hogwarts == "Gryffindor" &
                      (df$hair_length < 10 | df$shoe_size < 38),]
```

Красота!
  
```{block, type = "rmdtask"}
Задание: Уберите из дата.фрейма всех подозрительных респондентов - и тех, у кого больше двух глаз, и тех, у кого нереалистичный рост (скажем, меньше, чем 140 см, или больше, чем 220 см), если такие есть, и тех, кто ответил, что они не рождались в вопросе про месяц рождения. 
```

```{block, type = "rmdtask"}
Задание: Создайте отдельный дата.фрейм, в котором у нас будут только люди, которые родились зимой или осенью, и попали бы в Хогвартсе или в Слизерин, или в Рейвенкло.
```

### Фильтрация по результату функции

Иногда мы хотим отфильтровать значения не по абсолютному условию (все респонденты, у которых больше 1 сиблинга), а по относительному (все респонденты, у которых больше сиблингов, чем в среднем в выборке). Чтобы это сделать, мы можем сравнивать значения вектора или колонки дата.фрейма с результатом какой-нибудь функции, например, `mean()`.

Это можно сделать в две строки, сначала посчитав среднее, а потом использовав его в сравнении:
  
```{r}
meanSibs <- mean(df$siblings)
dfAboveMeanSibs <- df[df$siblings > meanSibs,]
```


```{r}
dfAboveMeanSibs <- df[df$siblings > mean(df$siblings),]
```


### Фильтрация для группировки

Часто мы хотим узнать что-нибудь про разные группы людей, которые есть в наших данных. Например, может быть, мы напоили испытуемых кофе, чаем или водой и ожидаем, что в зависимости от напитка они будут хуже или лучше решать задачи - тогда мы хотим посчитать, сколько задач в среднем решили испытуемые из каждой группы. Здесь нам тоже может пригодиться фильтрация.

Давайте узнаем, сколько в средним братьев и сестёр у наших респондентов, которые в Хогвартсе попали бы на разные факультеты. Для этого мы произведём четыре отдельных фильтрации (по одной на каждый факультет), а из колонок выберем только `siblings`.
(Если вы не помните, как пишутся факультеты, то всегда можно проверить с помощью `unique(df$hogwarts)` - эта команда вернёт все уникальные значения в векторе).
```{r}
siblingsGr <- df[df$hogwarts == "Gryffindor", "siblings"]
siblingsRav <- df[df$hogwarts == "Ravenclaw", "siblings"]
siblingsSl <- df[df$hogwarts == "Slytherin", "siblings"]
siblingsHuff <- df[df$hogwarts == "Hufflepuff", "siblings"]
```

И теперь можно воспользоваться функцией `mean()`, чтобы посчитать среднее значение каждого вектора:

```{r}
mean(siblingsGr)
mean(siblingsRav)
mean(siblingsSl)
mean(siblingsHuff)
```

```{block, type = "rmdtask"}
Задание: Воспользуйтесь функцией `max()`, чтобы найти самого высокого человека для каждого уровня игры на гитаре.
```

Такой подход, конечно, не самый эффективный - если у вас всего четыре категории, то ничего страшного, но что если у вас их, например, сто? Сразу хочется как-то это дело автоматизировать, и сейчас мы научимся это делать. Но перед этим я хочу дать вам совет: иногда вы не будете помнить, как что-то сделать эффективно (может быть, на хакатоне в субботу у вас будет такая проблема) - и тогда нет никакого зашквара в том, чтобы сделать, как можете. Эффективный код это прекрасно, но самое прекрасное это код, который работает и делает то, что вам нужно :) Эффективность приходит с опытом, так что пока я бы не советовала переживать о ней слишком сильно.

### Введение в data.table

Дата.фрейм это структура данных, которая по умолчанию встроена в R. Но большинство людей в своей реальной работе с данными используют одну из двух внешних библиотек: или `data.table`, или `dplyr`. Обе этих библиотеки имеют свою структуру для табличных данных (собственно, `data.table` в первой, `tibble` во второй) с расширенным функционалом. 
Ходят слухи, что если зайти в чат про R в пятницу вечером, там будут спорить или про R vs. Python, или про data.table vs. dplyr. У каждой библиотеки есть свои сильные и слабые стороны (`data.table` быстрее и лаконичнее, с `dplyr`  получается более "читаемый" код). Среди организаторов АнДана есть сторонники обеих библиотек (и на Питоне многие из нас тоже пишут, кстати :D). Лично я (Маша) считаю, что важно хорошо знать хотя бы одну - в целом, любую, а со второй, если надо, дальше можно разобраться. В этом курсе мы с вами будем пользоваться `data.table`.

Итак, как же воспользоваться внешней библиотекой? Для этого вам нужно будет выполнить две команды. Во-первых, библиотеку нужно установить с помощью команды `install.packages()`. Обратите внимание, что имя библиотеки пишется в кавычках:
  
```{r, eval = FALSE}
install.packages('data.table')
```

Устанавливать библиотеку нужно один раз, и если вы молодечик, то сделали это до школы :)

Во-вторых, библиотеку нужно подгрузить (другими словами, активировать) с помощью команды `library()`. Это нужно делать в начале каждой рабочей сессии - то есть, каждый раз, когда вы открываете RStudio. Обычно принято декларировать все библиотеки, которые вы используете в скрипте, в самом верху скрипта (если вы проскроллите наверх, то увидите, что я так и сделала). Здесь имя библиотеки пишется без кавычек:

```{r, eval = FALSE}
library(data.table)
```

Создать дата.тейбл с нуля можно так же, как и дата.фрейм, только используя функцию `data.table()`:

```{r}
dt <- data.table(number = 1:5,
                 name = c("Masha", "Sasha", "Pet'ka", "Dasha", "Vladimir Petrovich"))
```

Превратить имеющийся дата.фрейм в дата.тейбл - с помощью функции `as.data.table()`:
```{r}
dt <- as.data.table(df)
```



А загрузить csv-документ сразу в дата.тейбл можно с помощью функции `fread()`:
  
```{r, include=FALSE}
dt <- fread("data/about_us_eng.csv")
```

```{r, eval=FALSE}
dt <- fread("about_us_eng.csv")
```


```{r}
str(dt)
```
На первый взгляд наш дата.тейбл выглядит совершенно так же, как дата.фрейм. Больше скажу - с ним можно делать всё то же самое, что с дата.фреймом - фильтровать строки и колонки по индексам и обращаться к колонкам с помощью `$`:
  
```{r}
dt[1,1]
dt[1,]
dt[,1]
dt[1:3,]
dt$height
```


Но помимо этого у дата.тейблов есть очень крутой дополнительный функционал со своим специфическим синтаксисом. У дата.фрейма в квадратных скобках две части: df[фильтрация строк, фильтрация столбцов]. У дата.тейбла - три, да ещё и смысл второй поменялся: dt[фильтрация строк, выражение, параметр]. Перед первой запятой мы выбираем, какие строки мы хотим оставить в дата.тейбле - и теперь мы можем обращаться к колонкам напрямую, не используя конструкцию типа `df$height`, дата.тейбл по умолчанию считает, что внутри квадратных скобок вы можете обращаться к колонкам:
```{r}
dt[height > 165, ]
```
Между первой и второй запятой мы уточняем, что мы хотим сделать с колонками. Мы можем просто выбрать одну колонку и "достать" только её:
```{r}
dt[height > 165, eye_number]
```

Можем выбрать колонку и произвести над ней какую-нибудь операцию:
```{r}
dt[height > 165, max(eye_number)]
```


В предыдущей команде мы *сначала* выбрали только те строки (= респондентов), которые выше 165 см, а потом узнали, какое среди них максимальное число глаз.

А можем создать новую колонку внутри нашего дата.тейбла. Для этого мы будем использовать новый оператор, `:=` (Владимир Львович Волохонский называет его "приписька". Живите теперь тоже с этим знанием):
```{r}
dt[, height_meters := height/100]
```

Теперь у нас в дата.тейбле есть колонка `height_meters`, в которой хранится рост каждого испытуемого в метрах (то есть, 165 см превращается в 1.65 м). Обратите внимание - я не фильтровала строки, перед первой запятой ничего нет. Но *поставить* её надо, чтобы дата.тейбл понял, что вы пишете код `height_meters := height/100` во втором компоненте.

Но и это не самое клёвое! Ведь у нас есть третья часть (следите за руками - это часть после двух запятых). В третьей части мы можем указать, по какой колонке *сгруппировать* данные. Следующая строчка исключит всех респондентов, у которых больше двух глаз, и посчитает среднюю длину волос для каждого факультета:
  
```{r}
dt[eye_number <= 2, mean(hair_length), by = hogwarts]
```

```{block, type = "rmdtask"}
Задание: Найдите самого высокого человека, родившегося в каждый из месяцев. Тех, кто в вопросе про месяцы указал "Я не рождался(-лась)", исключите из подсчётов.

Подсказка: функция `max()` выдаст NA для одного из месяцев, потому что кто-то не ответил на вопрос о росте. Исключите NA из подсчётов: `max(height, na.rm = TRUE)`. `na.rm` значит NA remove - то бишь, убирать ли NA при поиске максимального значения.
```

```{block, type = "rmdtask"}
Задание: С помощью функции `sum()` узнайте, сколько суммарно братьев и сестёр у всех голубоглазых. А сколько у всех зеленоглазых? Найдите оба ответа одной строчкой кода :)
```

```{block, type = "rmdtask"}
Задание: Какой средний размер обуви у тех, кто выбрал чай (а не кофе или потанцевать)?
```

Если у вас есть вопросы про эту главу, скорее задайте их в канале #day1-afternoon-filter. Если после выполнения заданий у вас остались время и силы, вы можете воспользоваться тем, что мы сегодня прошли, чтобы постараться и найти самые интересные факты о нашем датасете. А если вы устали - идите отдыхать! :) Завтра - больше.